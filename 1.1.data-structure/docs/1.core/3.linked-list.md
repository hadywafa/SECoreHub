# ğŸ”— **Linked List Data Structure: Deep Dive**

> A **Linked List** is a linear data structure where each element (called a **node**) points to the **next** node â€” like a **chain of boxes** ğŸ”—.

---

<div style="text-align: center">
    <img src="images/linked-list.png" style="border-radius: 10px; width: 60%;" alt="linked-list">
</div>

---

## ğŸ“¦ Memory Behavior: Heap vs Stack

- A **linked list** lives in the **heap**, even if it's declared as a local variable.
- Each **Node** is a separate object in the heap and contains:

  - A **value**
  - A **pointer (reference)** to the next node

> The **stack** stores only the reference (head) to the first node, not the list contents.

---

## ğŸ§  Visual Representation

```plaintext
[HEAD] â”€â–¶ [10|â­¢] â”€â–¶ [20|â­¢] â”€â–¶ [30|null]
  â–²         â–²         â–²
 stack     heap      heap
```

Each node is dynamically allocated. Unlike arrays, memory is **not contiguous**.

---

## ğŸ•’ Time Complexity Table

| Operation            | Singly Linked List | Why?                                                              |
| -------------------- | ------------------ | ----------------------------------------------------------------- |
| ğŸ” Lookup (by index) | O(n)               | Must traverse from the head                                       |
| ğŸ” Lookup (by value) | O(n)               | Linear search â€” one-by-one                                        |
| â• Insert First      | O(1)               | Only update `head` pointer                                        |
| â• Insert Last       | O(1)\*             | Requires a `tail` pointer; else O(n) to traverse                  |
| â• Insert Middle     | O(n)               | Need to traverse to that position                                 |
| âŒ Delete First      | O(1)               | Just update `head`                                                |
| âŒ Delete Last       | O(n)               | Must traverse to node before last (unless it's **doubly linked**) |
| âŒ Delete Middle     | O(n)               | Need to find previous node                                        |

---

## âš™ï¸ Built-in `LinkedList<T>` Operations in C\

### âœ… AddFirst

```csharp
linkedList.AddFirst(5); // O(1)
```

### âœ… AddLast

```csharp
linkedList.AddLast(10); // O(1) with tail pointer
```

### âœ… AddBefore

```csharp
var node = linkedList.Find(5);
linkedList.AddBefore(node, 7); // O(1) for insert, O(n) for Find
```

### âœ… AddAfter

```csharp
var node = linkedList.Find(5);
linkedList.AddAfter(node, 8); // O(1) insert
```

### âœ… Remove

```csharp
linkedList.Remove(10); // O(n)
```

### âœ… RemoveFirst

```csharp
linkedList.RemoveFirst(); // O(1)
```

### âœ… RemoveLast

```csharp
linkedList.RemoveLast(); // O(n)
```

### âœ… Find / Contains

```csharp
var node = linkedList.Find(5);      // O(n)
bool hasValue = linkedList.Contains(7); // O(n)
```

---

## ğŸ§‘â€ğŸ’» Custom Implementation (Singly Linked List)

### ğŸ§± Node<T>

```csharp
public class Node<T>
{
    public T Value { get; set; }
    public Node<T> Next { get; set; }

    public Node(T value)
    {
        Value = value;
        Next = null;
    }
}
```

---

### ğŸ”— HwLinkedList<T>

```csharp
public class HwLinkedList<T>
{
    private Node<T> Head { get; set; }
    private Node<T> Tail { get; set; }

    public bool IsEmpty() => Head == null;
}
```

---

### ğŸ”§ AddLast

```csharp
public void AddLast(T value)
{
    var newNode = new Node<T>(value);
    if (IsEmpty())
        Head = Tail = newNode;
    else
    {
        Tail.Next = newNode;
        Tail = newNode;
    }
}
```

---

### ğŸ”§ AddFirst

```csharp
public void AddFirst(T value)
{
    var newNode = new Node<T>(value);
    if (IsEmpty())
        Head = Tail = newNode;
    else
    {
        newNode.Next = Head;
        Head = newNode;
    }
}
```

---

### ğŸ” IndexOf

```csharp
public int IndexOf(T value)
{
    int index = 0;
    var current = Head;
    while (current != null)
    {
        if (EqualityComparer<T>.Default.Equals(current.Value, value))
            return index;
        current = current.Next;
        index++;
    }
    return -1;
}
```

---

## ğŸ§  Real-World Analogy

> Think of a linked list like a **scavenger hunt** ğŸ§­
> Each clue (node) tells you where to find the next one. You **canâ€™t jump to clue #5** directly â€” you must follow the chain from the start.

---

## âš”ï¸ Linked List ğŸ†š Array

<div  align="center">
    <img src="images/linkedList-vs-array.png" style="border-radius: 10px; width: 60%;" alt="linked-list-vs-array">

---

| Feature              | Array                     | Linked List                |
| -------------------- | ------------------------- | -------------------------- |
| Memory Allocation    | Contiguous (heap)         | Non-contiguous (heap)      |
| Random Access        | âœ… Yes (O(1))             | âŒ No (O(n))               |
| Insert/Delete at End | âŒ Costly (O(n))          | âœ… O(1) if tail is tracked |
| Insert/Delete Start  | âŒ O(n) (shift elements)  | âœ… O(1)                    |
| Size Flexibility     | âŒ Fixed or resize needed | âœ… Fully dynamic           |
| Cache-Friendly       | âœ… Yes                    | âŒ No (non-contiguous)     |

</div>

---

## ğŸ”„ Singly vs Doubly Linked List

<div  align="center">
    <img src="images/singly-vs-doubly-linked-list.png" style="border-radius: 10px; width: 60%;" alt="singly vs doubly linked list">

---

| Feature            | Singly Linked List  | Doubly Linked List      |
| ------------------ | ------------------- | ----------------------- |
| Nodes point to     | Next                | Previous â¬…ï¸ and Next â¡ï¸ |
| Delete last node   | O(n)                | âœ… O(1)                 |
| Insert before node | âŒ Hard (need prev) | âœ… Easy                 |
| Memory usage       | Less                | More (extra pointer)    |

</div>

---

## ğŸ” Circular Linked Lists

> A **circular linked list** connects the **tail back to the head**, forming a full loop ğŸ”„.

- Can be **singly or doubly** linked
- Common in **round-robin schedulers**, **queues**, etc.

---

## âœ… When to Use a Linked List

| Use Case                        | Recommendation                     |
| ------------------------------- | ---------------------------------- |
| Frequent insert/delete at start | âœ… Linked list                     |
| Random access                   | âŒ Use array or `List<T>`          |
| No fixed size in advance        | âœ… Linked list                     |
| Memory overhead is critical     | âŒ Use array (more cache-friendly) |

---

## ğŸ“Œ Final Notes

- `LinkedList<T>` in C# is a **doubly linked list**
- All operations like `AddFirst`, `RemoveLast` are optimized with O(1) where possible
- But searching is **still O(n)** â€” **no indexing** like arrays
