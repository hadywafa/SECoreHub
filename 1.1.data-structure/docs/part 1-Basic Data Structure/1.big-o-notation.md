# ğŸ§  **Big O Notation: Mastering Algorithm Performance**

> _"How fast is your code as the input grows?"_
> Thatâ€™s what **Big O Notation** helps us answer.

---

<div style="text-align: center">
    <img src="images/big-o-notation-1.png" style="border-radius: 10px; width: 40%;" alt="big-o-notation-1">
</div>
<div style="text-align: center">
    <img src="images/big-o-notation-2.png" style="border-radius: 10px; width: 40%;" alt="big-o-notation-2">
</div>
<div style="text-align: center">
    <img src="images/big-o-notation-3.png" style="border-radius: 10px; width: 40%;" alt="big-o-notation-3">
</div>

---

## ğŸ“ **What Is Big O Notation?**

Big O Notation describes **how an algorithm scales** with input size `n`. Itâ€™s not about exact execution time â±ï¸ â€” itâ€™s about **growth rate** ğŸ“ˆ as input increases.

---

## ğŸ”¢ **1. O(1) â€” Constant Time**

- Execution time is **independent of input size**.
- Whether the array has 1 or 1,000,000 elements, the time stays the same.

```cs
public void LogFirstElement(int[] numbers)
{
    Console.WriteLine(numbers[0]);
    Console.WriteLine(numbers[0]);
}
```

âœ… Even two operations = still O(1). We **ignore constants** in Big O.

---

## ğŸ“¶ **2. O(n) â€” Linear Time**

- Execution time **grows linearly** with input size.
- One operation per element.

### ğŸ” Example

```cs
public void LogAllElements(int[] numbers)
{
    foreach (var num in numbers)
        Console.WriteLine(num);
}
```

---

### âš™ï¸ Combined Examples

```cs
// O(1 + n + 1) â†’ O(n)
public void LogWithExtras(int[] numbers)
{
    Console.WriteLine("Start");
    foreach (var num in numbers)
        Console.WriteLine(num);
    Console.WriteLine("End");
}
```

```cs
// O(n + n) â†’ O(2n) â†’ O(n)
public void DoubleLoop(int[] numbers)
{
    foreach (var num in numbers)
        Console.WriteLine(num);

    foreach (var num in numbers)
        Console.WriteLine(num);
}
```

```cs
// O(m + n)
public void TwoInputs(int[] numbers, string[] names)
{
    foreach (var num in numbers)
        Console.WriteLine(num);

    foreach (var name in names)
        Console.WriteLine(name);
}
```

ğŸ§  Rule: **Different loops over different inputs = additive (O(n + m))**
Same input looped twice = still **linear** (O(n)).

---

## ğŸªœ **3. O(nÂ²) â€” Quadratic Time**

- Time grows **exponentially with input size**.
- Most commonly seen in **nested loops**.

### ğŸ«§ Bubble Sort Example

```cs
public void BubbleSort(int[] array)
{
    for (int i = 0; i < array.Length - 1; i++)
    {
        for (int j = 0; j < array.Length - i - 1; j++)
        {
            if (array[j] > array[j + 1])
            {
                // Swap
                int temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
}
```

ğŸ” Two nested loops â†’ O(nÂ²)

---

## ğŸ“‰ **4. O(log n) â€” Logarithmic Time**

- Input size increases, but **steps grow slowly**.
- Most famously used in **binary search** ğŸ§­.

### ğŸ” Binary Search Example

```cs
public int BinarySearch(int[] sortedArray, int target)
{
    int left = 0;
    int right = sortedArray.Length - 1;

    while (left <= right)
    {
        int mid = left + (right - left) / 2;

        if (sortedArray[mid] == target)
            return mid;

        if (sortedArray[mid] < target)
            left = mid + 1;
        else
            right = mid - 1;
    }

    return -1;
}
```

â¡ï¸ Each step cuts the input in half â†’ **log base 2**

---

## ğŸªœğŸ” **5. O(n log n) â€” Linearithmic Time**

- **Divide-and-conquer** meets **linear processing**.
- Found in algorithms like **Merge Sort**, **Quick Sort**, and some tree operations.

ğŸ§  Intuition:

- You divide things up (`log n`)
- Then merge or combine results (`n`)

> Merge Sort = O(n log n)

---

## ğŸ’¥ **6. O(2â¿) â€” Exponential Time**

- Time **doubles with every new element**.
- Common in naive recursive problems like **Fibonacci** or **brute-force subsets**.

### ğŸ§¨ Example

```cs
public int Fibonacci(int n)
{
    if (n <= 1)
        return n;

    return Fibonacci(n - 1) + Fibonacci(n - 2);
}
```

â¡ï¸ Each call creates **2 more calls** â†’ very inefficient
Use **memoization** to reduce to O(n)

---

## ğŸ”‚ Common Time Complexities Chart

| Big O      | Description                | Example                     |
| ---------- | -------------------------- | --------------------------- |
| O(1)       | Constant                   | Accessing an array element  |
| O(log n)   | Logarithmic                | Binary search               |
| O(n)       | Linear                     | Simple for-loop             |
| O(n log n) | Linearithmic               | Merge Sort                  |
| O(nÂ²)      | Quadratic                  | Nested loops                |
| O(2â¿)      | Exponential                | Naive recursion (Fibonacci) |
| O(n!)      | Factorial (extremely slow) | Traveling Salesman problem  |

---

## ğŸ§  Final Tips

- **Drop constants** â†’ O(2n) becomes O(n)
- **Nested loops** often = O(nÂ²)
- **Separate loops over different inputs?** â†’ Add (O(m + n))
- **Recursive trees?** â†’ Analyze depth Ã— work per level
