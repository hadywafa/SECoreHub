# ğŸ How to Get the Minimum Value in a Binary Tree

## ğŸ‘‡ Scenario 1: General Binary Tree (Not BST)

A **Binary Tree** is a tree where:

- Each node has at most 2 children
- The nodes can be in **any order**

### âœ… You must check **every node** to find the minimum

### ğŸ” Recommended Approach: **DFS Traversal (Recursive)**

```csharp
int FindMin(TreeNode? root)
{
    if (root == null)
        throw new ArgumentException("Tree is empty");

    int leftMin = FindMin(root.left);
    int rightMin = FindMin(root.right);

    return Math.Min(root.val, Math.Min(leftMin, rightMin));
}
```

### ğŸ§  **How it works:**

- You compare the current node value to the min of left and right subtrees
- Recursion checks every node

âœ… Time complexity: **O(n)**  
âœ… Space complexity: **O(h)** (recursion stack)

---

### ğŸŒŠ Alternative: **BFS (Level Order)**

```csharp
int FindMinBFS(TreeNode? root)
{
    if (root == null) return int.MaxValue;

    var queue = new Queue<TreeNode>();
    queue.Enqueue(root);
    int minValue = int.MaxValue;

    while (queue.Count > 0)
    {
        var node = queue.Dequeue();
        minValue = Math.Min(minValue, node.val);

        if (node.left != null) queue.Enqueue(node.left);
        if (node.right != null) queue.Enqueue(node.right);
    }

    return minValue;
}
```

âœ… Uses a queue  
âœ… Useful when you want to avoid recursion  
âœ… Time: O(n), Space: O(n)

---

## ğŸŒ² Scenario 2: Binary Search Tree (BST)

In a **BST**, the left child is always less than the parent â€” so the **minimum value is the leftmost node**.

### âœ… Efficient approach: Traverse only left side

```csharp
int FindMinBST(TreeNode root)
{
    if (root == null)
        throw new ArgumentException("Tree is empty");

    while (root.left != null)
        root = root.left;

    return root.val;
}
```

âœ… Time complexity: **O(h)**  
âœ… Space complexity: **O(1)** if iterative, **O(h)** if recursive
(Where `h` is the height of the tree)

---

## ğŸ§  When to Use Which Approach?

| Tree Type    | Best Approach   | Time                                  |
| ------------ | --------------- | ------------------------------------- |
| General Tree | DFS or BFS      | O(n)                                  |
| BST          | Leftmost search | O(log n) for balanced BST, O(n) worst |

---

## âœ… Visual Example

```ini
        10
       /  \
      5    20
     / \
    2   8
   /
  1
```

### â¤ **General Tree:**

- DFS checks all nodes â†’ finds 1 as the minimum

### â¤ **BST:**

- Go left â†’ 10 â†’ 5 â†’ 2 â†’ 1 â†’ âœ… stop!

---

## ğŸ§ª Summary

| Method          | When to Use        | Notes              |
| --------------- | ------------------ | ------------------ |
| DFS (Recursive) | General tree       | Simple and clear   |
| BFS (Queue)     | General tree       | Avoids recursion   |
| Leftmost (Iter) | Binary Search Tree | Fastest way in BST |
