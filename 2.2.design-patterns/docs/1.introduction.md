# üß† **Introduction to Design Patterns in C#**

> Design Patterns are **battle-tested solutions** to common software problems ‚Äî a developer‚Äôs architectural toolkit üß∞

---

> Core are => 4 for frontend(Decorator, Command, Momento, Observer) and 4 for backend(Singleton, Iterator, Builder, Mediator)

---

## üí° What Are Design Patterns?

> A **design pattern** is a **reusable, general solution** to a commonly occurring problem in software design.
> It‚Äôs not code ‚Äî it‚Äôs a **template** you can apply to real scenarios.

‚úÖ Patterns:

- Solve **specific design problems**
- Use **object-oriented concepts**
- Improve code **flexibility**, **scalability**, and **maintainability**

---

## üéØ Why Use Design Patterns?

| Benefit üü¢                  | Why It Matters üß†                         |
| --------------------------- | ----------------------------------------- |
| Reusability                 | Don't reinvent the wheel üöò               |
| Standardized language       | ‚ÄúLet‚Äôs use a Singleton‚Äù = clear to all üó£Ô∏è |
| Proven solutions            | Time-tested and community-validated üíØ    |
| Maintainability             | Easier to refactor and extend üîß          |
| Flexibility via Abstraction | Promotes loosely-coupled architecture üîå  |

---

## üß© Pattern vs Principle vs Architecture

| Concept          | What It Does                                     |
| ---------------- | ------------------------------------------------ |
| **Principle**    | General rule for writing good code (e.g., SOLID) |
| **Pattern**      | Concrete solution template for common problem    |
| **Architecture** | System-wide structure and high-level decisions   |

---

## üì¶ Design Pattern Classifications

Design Patterns are grouped by **intent**.
Let‚Äôs break them into the **classic 3 categories** from the GoF book (Gang of Four):

---

### üèóÔ∏è 1. **Creational Patterns**

> Concerned with **object creation** logic
> Help make code **independent of how objects are created**

| Pattern Name         | Use Case                                       |
| -------------------- | ---------------------------------------------- |
| **Singleton**        | Only one instance ever (e.g., Logger)          |
| **Factory Method**   | Defer object creation to subclasses            |
| **Abstract Factory** | Create families of related objects             |
| **Builder**          | Step-by-step construction of complex objects   |
| **Prototype**        | Clone existing objects instead of building new |

---

### üß± 2. **Structural Patterns**

> Concerned with **object composition and relationships**
> Help ensure that pieces fit together cleanly

| Pattern Name  | Use Case                                          |
| ------------- | ------------------------------------------------- |
| **Adapter**   | Convert one interface to another                  |
| **Bridge**    | Decouple abstraction from implementation          |
| **Composite** | Treat groups of objects as one (tree structures)  |
| **Decorator** | Add behavior without changing original class      |
| **Facade**    | Provide a simplified interface over complex logic |
| **Flyweight** | Minimize memory by sharing similar objects        |
| **Proxy**     | Stand-in for real object to control access        |

---

### ü§ù 3. **Behavioral Patterns**

> Concerned with **communication between objects**
> Help with **control flow** and object interaction

| Pattern Name                | Use Case                                         |
| --------------------------- | ------------------------------------------------ |
| **Strategy**                | Select behavior at runtime (e.g., sorting logic) |
| **Observer**                | Notify many objects of state changes             |
| **Command**                 | Encapsulate requests as objects                  |
| **Chain of Responsibility** | Pass request along chain until handled           |
| **Template Method**         | Define algorithm skeleton, allow steps override  |
| **State**                   | Change object behavior based on internal state   |
| **Mediator**                | Centralized communication between components     |
| **Memento**                 | Capture and restore object state (undo)          |
| **Visitor**                 | Add operations to classes without modifying them |
| **Iterator**                | Sequentially access elements of a collection     |
| **Interpreter**             | Evaluate language grammar or expression trees    |

---

## üß† Real-World Analogy

| Classification | Analogy üß†                                      |
| -------------- | ----------------------------------------------- |
| **Creational** | Choosing **how** to create a car üöó             |
| **Structural** | How parts of the car **fit together** üß±        |
| **Behavioral** | How the car **interacts with the driver** üßë‚Äç‚úàÔ∏è |
