# üèóÔ∏è SOLID Principle #5 ‚Äì **D: Dependency Inversion Principle (DIP)**

> **‚ÄúHigh-level modules should not depend on low-level modules. Both should depend on abstractions.‚Äù**

---

<div style="text-align: center;">
    <img src="images/dip-definition.png" alt="DIP definition" style="width: 60%; border-radius: 10px;"/>
</div>

---

<div style="text-align: center;">
    <img src="images/dip-example.png" alt="dip-example" style="width: 60%; border-radius: 10px;"/>
</div>

---

## üß† What Does That Really Mean?

DIP flips traditional dependency direction:

- Instead of high-level logic (business code) calling directly into low-level details (DB, file system, API),
- Both depend on **abstractions** (interfaces)

> ‚úÖ Code becomes **loosely coupled**, **easier to maintain**, and **unit-test friendly**

---

## ‚ùå Anti-Example (Tight Coupling)

```csharp
public class ReportService
{
    private readonly SqlReportRepository _repository = new();

    public void GenerateReport()
    {
        var report = _repository.GetReport(); // Direct dependency
        Console.WriteLine(report);
    }
}
```

### ‚ùóWhat's wrong?

- `ReportService` is tightly coupled to `SqlReportRepository`
- Can‚Äôt switch to file-based or mock storage easily
- Violates DIP: high-level module depends on low-level details

---

## ‚úÖ Refactored with DIP

### Step 1: Define an abstraction

```csharp
public interface IReportRepository
{
    string GetReport();
}
```

### Step 2: Implement the interface

```csharp
public class SqlReportRepository : IReportRepository
{
    public string GetReport() => "Report from SQL DB";
}
```

### Step 3: Depend on the abstraction

```csharp
public class ReportService
{
    private readonly IReportRepository _repository;

    public ReportService(IReportRepository repository)
    {
        _repository = repository;
    }

    public void GenerateReport()
    {
        Console.WriteLine(_repository.GetReport());
    }
}
```

‚úÖ `ReportService` can now work with **any kind of repo**
‚úÖ Switch to mock repo in tests
‚úÖ Follows DIP perfectly

---

## üß∞ DIP in Practice (Framework-Level)

| Feature/Tool                  | How It Supports DIP                                 |
| ----------------------------- | --------------------------------------------------- |
| **Dependency Injection (DI)** | Constructor injection enforces abstraction          |
| **Interfaces & Abstractions** | Breaks concrete dependencies                        |
| **IoC Containers**            | Automates dependency resolution (like in .NET Core) |

---

## üí¨ Interview Insight

> "DIP ensures high-level code stays reusable and clean. When you inject interfaces instead of hardcoding dependencies, you make code testable and extensible. It‚Äôs the foundation of DI and clean architecture."

---

## ‚úÖ Summary

| Concept  | Dependency Inversion Principle (DIP)     |
| -------- | ---------------------------------------- |
| Goal     | Decouple high-level and low-level logic  |
| How      | Depend on abstractions (interfaces)      |
| Tools    | Interfaces, DI, IoC containers           |
| Benefits | Testability, flexibility, loose coupling |
