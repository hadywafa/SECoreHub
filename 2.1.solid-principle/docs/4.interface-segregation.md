# üîå SOLID Principle #4 ‚Äì **I: Interface Segregation Principle (ISP)**

> **‚ÄúClients should not be forced to depend on methods they do not use.‚Äù**

---

<div style="text-align: center;">
    <img src="images/isp-definition.png" alt="ISP definition" style="width: 60%; border-radius: 10px;"/>
</div>

---

<div style="text-align: center;">
    <img src="images/isp-example.png" alt="ISP example" style="width: 60%; border-radius: 10px;"/>
</div>

---

## üß† What Does That Mean?

> An interface should have **only the methods that are relevant to the implementing class**.
> If a class is forced to implement **unused or meaningless methods**, the interface is too fat.

---

## ‚ùå Anti-Example: Fat Interface

```csharp
public interface IMultiFunctionDevice
{
    void Print();
    void Scan();
    void Fax(); // üëÄ Who still faxes?
}

public class ModernPrinter : IMultiFunctionDevice
{
    public void Print() { /* ‚úÖ */ }
    public void Scan()  { /* ‚úÖ */ }
    public void Fax()   { throw new NotSupportedException(); } // ‚ùå
}
```

### ‚ùóProblem

- `ModernPrinter` is forced to implement **Fax()** even if it doesn't support it
- This leads to:

  - Exception-throwing methods
  - Useless code
  - Violated ISP

---

## ‚úÖ Refactored: Split Interfaces

```csharp
public interface IPrinter
{
    void Print();
}

public interface IScanner
{
    void Scan();
}

public interface IFax
{
    void Fax();
}

public class ModernPrinter : IPrinter, IScanner
{
    public void Print() { /* ‚úÖ */ }
    public void Scan()  { /* ‚úÖ */ }
}
```

‚úÖ Now classes **only implement what they need**
‚úÖ Smaller interfaces = more flexibility and separation of concerns

---

## üî¨ Real-World Signs of ISP Violation

| Symptom                                                | Likely Violation           |
| ------------------------------------------------------ | -------------------------- |
| Interfaces with 5+ unrelated methods                   | Too many responsibilities  |
| Implementing classes throw `NotImplementedException()` | Not all methods are needed |
| Client code ignores half the interface                 | Interface is too broad     |

---

## üîß Tools & Practices

| Strategy                     | Benefit                           |
| ---------------------------- | --------------------------------- |
| Break large interfaces       | Smaller, focused abstractions     |
| Use multiple interfaces      | Combine only what's needed        |
| Composition over inheritance | Build behavior modularly          |
| Marker interfaces            | When logic-less tagging is needed |

---

## üí¨ Interview Insight

> "The Interface Segregation Principle keeps systems modular. When interfaces grow too large, they reduce reusability and lead to brittle implementations. Clean interfaces reflect clean architecture."

---

## ‚úÖ Summary

| Principle      | Interface Segregation Principle (ISP)                 |
| -------------- | ----------------------------------------------------- |
| Core Idea      | No class should be forced to implement unused methods |
| Smell to Watch | Large interfaces, irrelevant method contracts         |
| Fix            | Split interfaces, use multiple smaller ones           |
| Goal           | Modular, flexible, intention-revealing code           |

---

## üß† Real-World Analogy

| Concept               | Analogy                                             |
| --------------------- | --------------------------------------------------- |
| Fat interface         | A Swiss Army knife where 90% of tools you never use |
| Segregated interfaces | Only carrying the exact tool you need üõ†Ô∏è            |
