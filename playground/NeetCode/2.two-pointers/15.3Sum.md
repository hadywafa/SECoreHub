# 3Sum Animation

## ğŸ§ª Example Input

```csharp
int[] nums = { -4, -1, -1, 0, 1, 2 };
```

After `Array.Sort(nums)`:

```ini
nums = [-4, -1, -1, 0, 1, 2]
         0   1   2   3  4  5
```

---

## ğŸ” Animation-Style Step-by-Step (Frame-by-Frame)

### ğŸ”¹ Frame 1: `i = 0`, `currentValue = -4`, `l = 1`, `r = 5`

```ini
[-4, -1, -1,  0,  1,  2]
 ^    ^              ^
 i    l              r
sum = -4 + (-1) + 2 = -3 â†’ too small â†’ move left up
```

â¡ï¸ `l++`

---

### ğŸ”¹ Frame 2: `i = 0`, `l = 2`, `r = 5`

```ini
[-4, -1, -1,  0,  1,  2]
 ^        ^            ^
 i        l            r
sum = -4 + (-1) + 2 = -3 â†’ too small â†’ move `l++`
```

â¡ï¸ `l++`

---

### ğŸ”¹ Frame 3: `i = 0`, `l = 3`, `r = 5`

```ini
[-4, -1, -1,  0,  1,  2]
 ^             ^       ^
 i             l       r
sum = -4 + 0 + 2 = -2 â†’ too small â†’ move `l++`
```

â¡ï¸ `l++`

---

### ğŸ”¹ Frame 4: `i = 0`, `l = 4`, `r = 5`

```ini
[-4, -1, -1,  0,  1,  2]
 ^                ^   ^
 i                l   r
sum = -4 + 1 + 2 = -1 â†’ too small â†’ `l++`
```

â¡ï¸ `l++` â†’ `l = 5`, loop exits (`l < r` fails)

---

## ğŸ”„ Next Outer Loop

â¡ï¸ `i = 1`, `currentValue = -1`, `l = 2`, `r = 5`

---

### ğŸ”¹ Frame 5: `i = 1`, `l = 2`, `r = 5`

```ini
[-4, -1, -1,  0,  1,  2]
      ^    ^           ^
      i    l           r
sum = -1 + (-1) + 2 = 0 â†’ ğŸ¯ FOUND TRIPLET

triplet = [-1, -1, 2]
key = "-1,-1,2" not in HashSet â†’ âœ… Add
```

â¡ï¸ Add to result
â¡ï¸ Add key to `seen`
â¡ï¸ `l++`, `r--`

---

### ğŸ”¹ Frame 6: `l = 3`, `r = 4`

```ini
[-4, -1, -1,  0,  1,  2]
      ^         ^   ^
      i         l   r
sum = -1 + 0 + 1 = 0 â†’ ğŸ¯ FOUND TRIPLET

triplet = [-1, 0, 1]
key = "-1,0,1" not in HashSet â†’ âœ… Add
```

â¡ï¸ Add to result
â¡ï¸ Add key to `seen`
â¡ï¸ `l++`, `r--` â†’ `l = 4`, `r = 3` â†’ exit loop

---

## ğŸ”„ Next `i = 2`, `currentValue = -1`

But `nums[2] == nums[1]`, and you're not skipping duplicates here, so it'll run again.

You'll compute:

```ini
[-1, 0, 1]
```

But it's already in `seen` â†’ won't add again âœ…

---

## ğŸ”š Final Results

The result list will contain:

```csharp
[
  [-1, -1, 2],
  [-1, 0, 1]
]
```

---

## âœ… Summary of Logic

| Part                          | Action                                             |
| ----------------------------- | -------------------------------------------------- |
| ğŸ” Outer Loop (`i`)           | Picks first number (`currentValue`)                |
| ğŸ” Inner Loop (`while l < r`) | Uses two-pointer technique to find complement pair |
| ğŸ§® `sum == 0`                 | Valid triplet â†’ check HashSet, then add            |
| ğŸ§  `seen`                     | Prevents duplicate triplets                        |
| ğŸ“‰ `sum < 0`                  | Move `l++` to increase sum                         |
| ğŸ“ˆ `sum > 0`                  | Move `r--` to decrease sum                         |

---

## âš ï¸ Why This Version Works (Even Without Duplicate Skip for `i`)

Because you're using:

```csharp
string tripletKey = $"{a},{b},{c}";
if (!seen.Contains(tripletKey))
```

Even if you hit the same `a` again, it will **not re-add duplicate triplets** thanks to `seen`.

---

## ğŸ§  Visual Legend

```text
 ^ = pointer
 l = left
 r = right
 i = currentValue
```
