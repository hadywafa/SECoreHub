# ğŸ”¢ Problem Recap

ğŸ“Œ **Input**: Unsorted integer array
ğŸ“Œ **Goal**: Return the length of the **longest consecutive sequence**
ğŸ“Œ **Constraint**: Must run in **O(n)** time

---

<div style="text-align: center;">
    <img src="image/128.LongestConsecutiveSequence/1754405651543.png" alt="1754405651543" style="width: 80%; border-radius: 10px;"/>
</div>

---

## ğŸ§  High-Level Intuition

You want to find the **longest streak of consecutive numbers**, like:

```txt
Input: [100, 4, 200, 1, 3, 2]
Longest streak: 1 â†’ 2 â†’ 3 â†’ 4
Output: 4
```

But you canâ€™t sort (`O(n log n)`), so we need something faster â€” **HashSet to the rescue** ğŸ¦¸â€â™‚ï¸

---

## ğŸ§® Step-by-Step Breakdown from the Image

### ğŸ”· Step 1: Store All Numbers in a HashSet

```csharp
var set = new HashSet<int>(nums);
```

This gives **O(1)** lookup time for any number.

```txt
Set = { 100, 4, 200, 1, 3, 2 }
```

---

### ğŸ” Step 2: Scan for the **Start of a Sequence**

Only begin counting a sequence if `num - 1` is **not in the set**.

In the image:

- `100 â†’ 99 âŒ not found` â†’ start sequence âœ…
- `4 â†’ 3 âœ… found` â†’ skip â›”
- `1 â†’ 0 âŒ not found` â†’ start sequence âœ…
- `3 â†’ 2 âœ… found` â†’ skip â›”
- `2 â†’ 1 âœ… found` â†’ skip â›”
- `200 â†’ 199 âŒ not found` â†’ start sequence âœ…

We start sequences only from the **leftmost end**.

---

### ğŸ“ Step 3: Count Length of Consecutive Sequence

When starting from `1`, check:

- `2 â†’ âœ…`
- `3 â†’ âœ…`
- `4 â†’ âœ…`
- `5 â†’ âŒ`

So: `1 â†’ 2 â†’ 3 â†’ 4` â†’ Length = 4 âœ…

---

### âœ… Final Result

- Sequence from `100`: length 1
- Sequence from `1`: length **4** ğŸ¥‡
- Sequence from `200`: length 1

ğŸ“¤ Return **4**

---

## â± Time & Space Analysis (Bottom of Image)

| Resource  | Complexity                              |
| --------- | --------------------------------------- |
| **Time**  | `O(n)` âœ… â€” Each number is visited once |
| **Space** | `O(n)` âœ… â€” For the HashSet             |

---

## ğŸ§  Why This Is Smart

- Doesnâ€™t sort â†’ avoids `O(n log n)`
- Doesnâ€™t revisit elements unnecessarily
- HashSet lookup is O(1) â€” perfect for this type of problem

---

## ğŸ¯ Visual Summary

```mermaid
flowchart LR
    A[nums array] --> B[Add all to HashSet]
    B --> C{num - 1 in set?}
    C -- No --> D[Start new sequence]
    C -- Yes --> E[Skip]
    D --> F[Expand num+1, num+2...]
    F --> G[Track max length]
    E --> G
```

---

## âœ… C# Code (Final, Clean Version)

```csharp
public class Solution {
    public int LongestConsecutive(int[] nums) {
        var set = new HashSet<int>(nums);
        int longest = 0;

        foreach (int num in nums) {
            if (!set.Contains(num - 1)) {
                int currentNum = num;
                int length = 1;

                while (set.Contains(currentNum + 1)) {
                    currentNum++;
                    length++;
                }

                longest = Math.Max(longest, length);
            }
        }

        return longest;
    }
}
```
