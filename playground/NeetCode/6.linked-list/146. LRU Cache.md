# üß† What is LRU Cache?

**LRU = Least Recently Used!**

It means:

- If the cache is **full**, we remove the **least recently used** item (the one we didn‚Äôt touch for the longest time).
- Every time we `get` or `put`, we **update** the item as **most recently used**.

---

## üèóÔ∏è Required Features

We need to:

- `get(key)` in **O(1)** time
- `put(key, value)` in **O(1)** time

---

## ‚úÖ What Data Structures Do We Need?

| Purpose                           | Use                     |
| --------------------------------- | ----------------------- |
| Fast lookup by key                | `Dictionary<int, Node>` |
| Track usage order (recent to old) | `Doubly Linked List`    |

Why doubly linked list?

Because:

- We can **remove and insert nodes in O(1)** time
- We can **move nodes to the front easily**

---

## üß± LRUCache Building Blocks

We'll make a class like this:

```csharp
public class LRUCache
{
    class Node
    {
        public int key, value;
        public Node prev, next;
        public Node(int key, int value)
        {
            this.key = key;
            this.value = value;
        }
    }

    private int capacity;
    private Dictionary<int, Node> map;
    private Node head, tail;
}
```

---

## üîÑ Helper Functions

We'll add:

```csharp
// 1. Remove a node from the list
void Remove(Node node)
{
    node.prev.next = node.next;
    node.next.prev = node.prev;
}

// 2. Insert a node right after head (most recent)
void InsertToFront(Node node)
{
    node.next = head.next;
    head.next.prev = node;
    head.next = node;
    node.prev = head;
}
```

---

## üí° Full Code (Simple and Clean)

```csharp
public class LRUCache
{
    class Node
    {
        public int key, value;
        public Node prev, next;
        public Node(int key, int value)
        {
            this.key = key;
            this.value = value;
        }
    }

    private int capacity;
    private Dictionary<int, Node> map;
    private Node head, tail;

    public LRUCache(int capacity)
    {
        this.capacity = capacity;
        map = new Dictionary<int, Node>();

        // Dummy head and tail to simplify insert/remove
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
    }

    public int Get(int key)
    {
        if (!map.ContainsKey(key)) return -1;

        Node node = map[key];

        // Move it to front (most recent)
        Remove(node);
        InsertToFront(node);

        return node.value;
    }

    public void Put(int key, int value)
    {
        if (map.ContainsKey(key))
        {
            // Update the value and move to front
            Node existing = map[key];
            existing.value = value;
            Remove(existing);
            InsertToFront(existing);
        }
        else
        {
            if (map.Count == capacity)
            {
                // Remove least recently used
                Node lru = tail.prev;
                Remove(lru);
                map.Remove(lru.key);
            }

            Node newNode = new Node(key, value);
            map[key] = newNode;
            InsertToFront(newNode);
        }
    }

    private void Remove(Node node)
    {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void InsertToFront(Node node)
    {
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
        node.prev = head;
    }
}
```

---

## üß™ Example Walkthrough

```csharp
var cache = new LRUCache(2);
cache.Put(1, 1); // {1}
cache.Put(2, 2); // {2, 1}
cache.Get(1);    // returns 1, move 1 to front => {1, 2}
cache.Put(3, 3); // remove 2, add 3 => {3, 1}
cache.Get(2);    // returns -1
```

---

## ‚úÖ Summary

| What You Learned  | Summary                                                |
| ----------------- | ------------------------------------------------------ |
| What is LRU Cache | Evict least recently used item                         |
| What to use       | Dictionary + Doubly Linked List                        |
| Time complexity   | O(1) for both `get` and `put`                          |
| Trick             | Dummy `head` and `tail` nodes for easier insert/remove |
